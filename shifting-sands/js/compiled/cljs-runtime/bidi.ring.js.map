{"version":3,"sources":["bidi/ring.cljc"],"mappings":";AAeA,AAAA;AAAA;;;AAAA,AAAaO;;AAAb,AAAAP,AAAA,AACYQ,AAAEC,AAAIC;AADlB,AAAA,AAAAT,AAAA,AAAA,AAAA,AAAA,AACYO,AAAAA;AADZN,AAAA,AAAAC,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACYM,AAAAA,AAAEC,AAAAA,AAAIC,AAAAA;;AADlB,AAAAL,AAAA,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAE,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACYG,AAAAA,AAAEC,AAAAA,AAAIC,AAAAA;;AADlB,AAAA,AAAAJ,AAAA,AACYE;;;;AADZ,AAAA;;;;AAAA,AACGL,AAASK,AAAEC,AAAIC;AADlB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACYF,AAAAA;AADZ,AACYA,AAAAA,AAAEC,AAAIC;;AADlB,AAAAV,AACYQ,AAAEC,AAAIC;;;;AADlB,AAKA,AAAA,AAAA,AAAAC,AAAAJ,AAAA,AAAA;;AAAA,AAAAI,AAAAR,AAAA,AAGE,AAAUU,AAAEJ,AAAID;AAAhB,AACE,AAACK,AAAAA,AAAAA,AAAEJ,AAAAA;;;AAJP,AAAA,AAAA,AAAA,AAAAG,AAOWE;;AAPX,AAAA,AAAA,AAOWA,AACT,AAAUC,AAAEN,AAAIO;AAAhB,AAAA,AAAA,AAAUD;AAAV,AACE,AAACZ,AAAQ,AAACc,AAAMF,AAAGN,AAAIO;;AAE3B,AAAA;;;;;AAAA,AAAAE,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAIFE,AAAMC;AAJV,AAKG,AAAQD;AAAR;AAAA,AAAA,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAA;;;AACA,AAAAG;AAAA,AAAA,AAAAC,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAb,AAAA,AAAAa,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAAC,AAAAF,AAAAA;AAAAA,AAAgChB;AAAhC,AAAAmB,AAAAH,AAAA,AAAaI;AAAb,AAAAD,AAAAH,AAAA,AAAiBK;AAAjB,AACE,AAAME,AAAK,AAAAC,AAAIH;AAAJ,AAAA,AAAAG;AAAAA;;AAAcJ;;;AAAzBE,AAEM,AAACK,AAAad,AAAMU,AAAKvB;AAF/BsB,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAnB,AAAA,AAAAmB,AAAA,AAAA,AAAA,AAAA,AAAAL,AAAAC,AAAAI,AAAAA;AAAAA,AACwCrB;AADxC,AAAAkB,AAAAG,AAAA,AACcG;AADd,AAAAN,AAAAG,AAAA,AACsBI;AADtB,AAGE,AAAMD;AAAN,AACE,AAAC/B,AACA,AAACoB,AAAAA,AAAAA,AAAWW,AAAAA,AACRzB,AACA,AAAA,AAAA,AAAC4B,AAAoBC,AAAMH,AAC3B,AAAA,AAAA,AAACE,AAA0BC,AAAMH,AACrC,AAAA,AAACT,AAAMa,AAAO7B,AAAuB,AAAC8B,AAAK/B;;AAN9C;;;;;AAVP,AAAA,AAAA,AAAMW,AAiBFE;AAjBJ,AAiBW,AAACmB,AAAanB,AAAMoB;;;AAjB/B,AAAA,AAAA,AAAMtB;;AAAN","names":["bidi$ring$Ring$request$dyn","x__4428__auto__","m__4429__auto__","bidi.ring/request","goog/typeOf","m__4426__auto__","cljs.core/missing-protocol","bidi.ring/Ring","_","req","match-context","goog.object/set","cljs.core/PROTOCOL_SENTINEL","f","cljs.core/Var","v","mc","cljs.core/deref","var_args","G__49313","bidi.ring/make-handler","js/Error","route","handler-fn","p__49314","map__49315","cljs.core.apply","cljs.core/hash-map","cljs.core.get","uri","path-info","map__49317","path","or__4126__auto__","handler","route-params","bidi.bidi/match-route*","cljs.core.update_in","cljs.core/merge","cljs.core/dissoc","cljs.core/keys","bidi.ring.make_handler","cljs.core/identity"],"sourcesContent":[";; Copyright \u00a9 2014, JUXT LTD.\n\n(ns bidi.ring\n  #?(:clj\n     (:require\n      [bidi.bidi :as bidi :refer :all]\n      [clojure.java.io :as io]\n      [ring.util.response :refer (file-response url-response resource-response)]\n      [ring.middleware.content-type :refer (wrap-content-type)]\n      [ring.middleware.not-modified :refer (wrap-not-modified)]\n      [ring.middleware.resource :refer (wrap-resource)])\n     :cljs\n     (:require\n      [bidi.bidi :as bidi :refer (match-route*)])))\n\n(defprotocol Ring\n  (request [_ req match-context]\n    \"Handle a Ring request, but optionally utilize any context that was\n    collected in the process of matching the handler.\"))\n\n(extend-protocol Ring\n  #?(:clj clojure.lang.Fn\n     :cljs function)\n  (request [f req _]\n    (f req))\n\n  #?(:clj clojure.lang.Var\n     :cljs cljs.core.Var)\n  (request [v req mc]\n    (request (deref v) req mc)))\n\n(defn make-handler\n  \"Create a Ring handler from the route definition data\n  structure. Matches a handler from the uri in the request, and invokes\n  it with the request as a parameter.\"\n  ([route handler-fn]\n   (assert route \"Cannot create a Ring handler with a nil Route(s) parameter\")\n   (fn [{:keys [uri path-info] :as req}]\n     (let [path (or path-info uri)\n           {:keys [handler route-params] :as match-context}\n           (match-route* route path req)]\n       (when handler\n         (request\n          (handler-fn handler)\n          (-> req\n              (update-in [:params] merge route-params)\n              (update-in [:route-params] merge route-params))\n          (apply dissoc match-context :handler (keys req)))))))\n  ([route] (make-handler route identity)))\n\n;; Any types can be used which satisfy bidi protocols.\n\n;; Here are some built-in ones.\n\n;; Redirect can be matched (appear on the right-hand-side of a route)\n;; and returns a handler that can redirect to the given target.\n#?(:clj\n   (defrecord Redirect [status target]\n     bidi/Matched\n     (resolve-handler [this m]\n       (when (= \"\" (:remainder m))\n         (cond-> m\n           true (assoc :handler this)\n           (not (string? target))\n           (assoc :location\n                  (apply path-for (:route m) target\n                         (apply concat (seq (:route-params m)))))\n           true (dissoc :remainder))))\n     (unresolve-handler [this m]\n       (when (= this (:handler m)) \"\"))\n     Ring\n     (request [f req m]\n       (if-let [location (if-not (string? target) (:location m) target)]\n         {:status  status\n          :headers {\"Location\" location}\n          :body    (str \"Redirect to \" location)}\n         {:status 500\n          :body   \"Failed to determine redirect location\"}))))\n\n#?(:clj\n   (defn redirect [target]\n     (->Redirect 302 target)))\n\n#?(:clj\n   (defn redirect-after-post [target]\n     (->Redirect 303 target)))\n\n;; Use this to map to paths (e.g. /static) that are expected to resolve\n;; to a Java resource, and should fail-fast otherwise (returning a 404).\n#?(:clj\n   (defrecord Resources [options]\n     bidi/Matched\n     (resolve-handler [this m]\n       (let [path (url-decode (:remainder m))]\n         (when (not-empty path)\n           (assoc (dissoc m :remainder)\n                  :handler\n                  (-> (fn [req]\n                        (if-let [res (resource-response (str (:prefix options) path))]\n                          res\n                          {:status 404}))\n                      (wrap-content-type options))))))\n     (unresolve-handler [this m]\n       (when (= this (:handler m)) \"\"))))\n\n#?(:clj\n   (defn resources [options]\n     (->Resources options)))\n\n;; Use this to map to resources, will return nil if resource doesn't\n;; exist, allowing other routes to be tried. Use this to try the path as\n;; a resource, but to continue if not found.  Warning: Java considers\n;; directories as resources, so this will yield a positive match on\n;; directories, including \"/\", which will prevent subsequent patterns\n;; being tried. The workaround is to be more specific in your\n;; patterns. For example, use /js and /css rather than just /. This\n;; problem does not affect Files (below).\n#?(:clj\n   (defrecord ResourcesMaybe [options]\n     bidi/Matched\n     (resolve-handler [this m]\n       (let [path (url-decode (:remainder m))]\n         (when (not-empty path)\n           (when-let [res (io/resource (str (:prefix options) path))]\n             (assoc (dissoc m :remainder)\n                    :handler (->\n                              (fn [req] (resource-response (str (:prefix options) path)))\n                              (wrap-content-type options)))))))\n     (unresolve-handler [this m]\n       (when (= this (:handler m)) \"\"))))\n\n#?(:clj\n   (defn resources-maybe [options]\n     (->ResourcesMaybe options)))\n\n;; Use this to map to files, using file-response. Options sbould include\n;; :dir, the root directory containing the files.\n#?(:clj\n   (defrecord Files [options]\n     bidi/Matched\n     (resolve-handler [this m]\n       (assoc (dissoc m :remainder)\n              :handler (->\n                        (fn [req] (file-response (url-decode (:remainder m))\n                                                {:root (:dir options)}))\n                        (wrap-content-type options)\n                        (wrap-not-modified))))\n     (unresolve-handler [this m]\n       (when (= this (:handler m)) \"\"))))\n\n#?(:clj\n   (defn files [options]\n     (->Files options)))\n\n;; Use this to route to an existing archive.\n;; :archive should be a resource\n;; :resource-prefix (defaults to /) says where in the archive the content is\n#?(:clj\n   (defrecord Archive [options]\n     bidi/Matched\n     (resolve-handler [this m]\n       (let [path (url-decode (:remainder m))]\n         (when (not-empty path)\n           (-> m\n               (assoc\n                :handler\n                (->\n                 (fn [req]\n                   (url-response (java.net.URL.\n                                  (str \"jar:\" (:archive options) \"!\"\n                                       (or (:resource-prefix options) \"/\") path))))\n                 (wrap-content-type)\n                 (wrap-not-modified)))\n               (dissoc :remainder)))))\n     (unresolve-handler [this m]\n       (when (= this (:handler m)) \"\"))))\n\n#?(:clj\n   (defn archive [options]\n     (->Archive options)))\n\n;; WrapMiddleware can be matched (appear on the right-hand-side of a route)\n;; and returns a handler wrapped in the given middleware.\n#?(:clj\n   (defrecord WrapMiddleware [matched middleware]\n     bidi/Matched\n     (resolve-handler [this m]\n       (let [r (resolve-handler matched m)]\n         (if (:handler r) (update-in r [:handler] middleware) r)))\n     (unresolve-handler [this m] (unresolve-handler matched m)))) ; pure delegation\n\n#?(:clj\n   (defn wrap-middleware [matched middleware]\n     (->WrapMiddleware matched middleware)))\n"]}